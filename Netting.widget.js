<BPUI.Page>
<div>
<BPUI.Dialog name="modalDlg_success"> Data was saved successfully ! </BPUI.Dialog>
<BPUI.Dialog name="modalDlg_error"> Error while data saving. Check the data and try again, please. </BPUI.Dialog>
<NettingContainer/> 
</div>
</BPUI.Page>


__________________________________________________

.alert {
  position: relative;
  padding: 0.75rem 1.25rem;
  margin-bottom: 1rem;
  border: 1px solid transparent;
  border-radius: 0.25rem;
}

.alert-heading {
  color: inherit;
}

.alert-link {
  font-weight: 700;
}

.alert-dismissible {
  padding-right: 4rem;
}

.alert-dismissible .close {
  position: absolute;
  top: 0;
  right: 0;
  padding: 0.75rem 1.25rem;
  color: inherit;
}

.alert-primary {
    color: #5cc3ff;
    background-color: #e2f5ff;
    border-color: #e2f5ff;
}

.alert-primary hr {
  border-top-color: #9fcdff;
}

.alert-primary .alert-link {
  color: #002752;
}

.alert-secondary {
  color: #383d41;
  background-color: #e2e3e5;
  border-color: #d6d8db;
}

.alert-secondary hr {
  border-top-color: #c8cbcf;
}

.alert-secondary .alert-link {
  color: #202326;
}

.alert-success {
  color: #155724;
  background-color: #d4edda;
  border-color: #c3e6cb;
}

.alert-success hr {
  border-top-color: #b1dfbb;
}

.alert-success .alert-link {
  color: #0b2e13;
}

.alert-info {
  color: #0c5460;
  background-color: #d1ecf1;
  border-color: #bee5eb;
}

.alert-info hr {
  border-top-color: #abdde5;
}

.alert-info .alert-link {
  color: #062c33;
}

.alert-warning {
  color: #856404;
  background-color: #fff3cd;
  border-color: #ffeeba;
}

.alert-warning hr {
  border-top-color: #ffe8a1;
}

.alert-warning .alert-link {
  color: #533f03;
}

.alert-danger {
  color: #721c24;
  background-color: #f8d7da;
  border-color: #f5c6cb;
}

.alert-danger hr {
  border-top-color: #f1b0b7;
}

.alert-danger .alert-link {
  color: #491217;
}

.alert-light {
  color: #818182;
  background-color: #fefefe;
  border-color: #fdfdfe;
}

.alert-light hr {
  border-top-color: #ececf6;
}

.alert-light .alert-link {
  color: #686868;
}

.alert-dark {
  color: #1b1e21;
  background-color: #d6d8d9;
  border-color: #c6c8ca;
}

.alert-dark hr {
  border-top-color: #b9bbbe;
}

.alert-dark .alert-link {
  color: #040505;
} 

.w-25 {
  width: 25% !important;
}

.w-50 {
  width: 50% !important;
}

.w-75 {
  width: 75% !important;
}

.w-100 {
  width: 100% !important;
}

.h-25 {
  height: 25% !important;
}

.h-50 {
  height: 50% !important;
}

.h-75 {
  height: 75% !important;
}

.h-100 {
  height: 100% !important;
}

.mw-100 {
  max-width: 100% !important;
}

.mh-100 {
  max-height: 100% !important;
}

.m-0 {
  margin: 0 !important;
}

.mt-0,
.my-0 {
  margin-top: 0 !important;
}

.mr-0,
.mx-0 {
  margin-right: 0 !important;
}

.mb-0,
.my-0 {
  margin-bottom: 0 !important;
}

.ml-0,
.mx-0 {
  margin-left: 0 !important;
}

.m-1 {
  margin: 0.25rem !important;
}

.mt-1,
.my-1 {
  margin-top: 0.25rem !important;
}

.mr-1,
.mx-1 {
  margin-right: 0.25rem !important;
}

.mb-1,
.my-1 {
  margin-bottom: 0.25rem !important;
}

.ml-1,
.mx-1 {
  margin-left: 0.25rem !important;
}

.m-2 {
  margin: 0.5rem !important;
}

.mt-2,
.my-2 {
  margin-top: 0.5rem !important;
}

.mr-2,
.mx-2 {
  margin-right: 0.5rem !important;
}

.mb-2,
.my-2 {
  margin-bottom: 0.5rem !important;
}

.ml-2,
.mx-2 {
  margin-left: 0.5rem !important;
}

.m-3 {
  margin: 1rem !important;
}

.mt-3,
.my-3 {
  margin-top: 1rem !important;
}

.mr-3,
.mx-3 {
  margin-right: 1rem !important;
}

.mb-3,
.my-3 {
  margin-bottom: 1rem !important;
}

.ml-3,
.mx-3 {
  margin-left: 1rem !important;
}

.m-4 {
  margin: 1.5rem !important;
}

.mt-4,
.my-4 {
  margin-top: 1.5rem !important;
}

.mr-4,
.mx-4 {
  margin-right: 1.5rem !important;
}

.mb-4,
.my-4 {
  margin-bottom: 1.5rem !important;
}

.ml-4,
.mx-4 {
  margin-left: 1.5rem !important;
}

.m-5 {
  margin: 3rem !important;
}

.mt-5,
.my-5 {
  margin-top: 3rem !important;
}

.mr-5,
.mx-5 {
  margin-right: 3rem !important;
}

.mb-5,
.my-5 {
  margin-bottom: 3rem !important;
}

.ml-5,
.mx-5 {
  margin-left: 3rem !important;
}

.p-0 {
  padding: 0 !important;
}

.pt-0,
.py-0 {
  padding-top: 0 !important;
}

.pr-0,
.px-0 {
  padding-right: 0 !important;
}

.pb-0,
.py-0 {
  padding-bottom: 0 !important;
}

.pl-0,
.px-0 {
  padding-left: 0 !important;
}

.p-1 {
  padding: 0.25rem !important;
}

.pt-1,
.py-1 {
  padding-top: 0.25rem !important;
}

.pr-1,
.px-1 {
  padding-right: 0.25rem !important;
}

.pb-1,
.py-1 {
  padding-bottom: 0.25rem !important;
}

.pl-1,
.px-1 {
  padding-left: 0.25rem !important;
}

.p-2 {
  padding: 0.5rem !important;
}

.pt-2,
.py-2 {
  padding-top: 0.5rem !important;
}

.pr-2,
.px-2 {
  padding-right: 0.5rem !important;
}

.pb-2,
.py-2 {
  padding-bottom: 0.5rem !important;
}

.pl-2,
.px-2 {
  padding-left: 0.5rem !important;
}

.p-3 {
  padding: 1rem !important;
}

.pt-3,
.py-3 {
  padding-top: 1rem !important;
}

.pr-3,
.px-3 {
  padding-right: 1rem !important;
}

.pb-3,
.py-3 {
  padding-bottom: 1rem !important;
}

.pl-3,
.px-3 {
  padding-left: 1rem !important;
}

.p-4 {
  padding: 1.5rem !important;
}

.pt-4,
.py-4 {
  padding-top: 1.5rem !important;
}

.pr-4,
.px-4 {
  padding-right: 1.5rem !important;
}

.pb-4,
.py-4 {
  padding-bottom: 1.5rem !important;
}

.pl-4,
.px-4 {
  padding-left: 1.5rem !important;
}

.p-5 {
  padding: 3rem !important;
}

.pt-5,
.py-5 {
  padding-top: 3rem !important;
}

.pr-5,
.px-5 {
  padding-right: 3rem !important;
}

.pb-5,
.py-5 {
  padding-bottom: 3rem !important;
}

.pl-5,
.px-5 {
  padding-left: 3rem !important;
}

.m-auto {
  margin: auto !important;
}

.mt-auto,
.my-auto {
  margin-top: auto !important;
}

.mr-auto,
.mx-auto {
  margin-right: auto !important;
}

.mb-auto,
.my-auto {
  margin-bottom: auto !important;
}

.ml-auto,
.mx-auto {
  margin-left: auto !important;
}

.text-white{
color:#FFF !important;
}

.table-responsive {
  display: block;
  width: 100%;
    max-width:100vw;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  -ms-overflow-style: -ms-autohiding-scrollbar;
}














.table {
  width: 100%;
  max-width: 100%;
  margin-bottom: 1rem;
  background-color: transparent;
 
}

.table th,
.table td {
  padding: 0.75rem;
  vertical-align: top;
  border-top: 1px solid #dee2e6;
}

.table thead th {
  vertical-align: bottom;
  border-bottom: 2px solid #dee2e6;
 
}

.table tbody + tbody {
  border-top: 2px solid #dee2e6;
}

.table .table {
  background-color: #fff;
}

.table-sm th,
.table-sm td {
  padding: 0.3rem;
}

.table-bordered {
  border: 1px solid #dee2e6;
}

.table-bordered th,
.table-bordered td {
  border: 1px solid #dee2e6;
}

.table-bordered thead th,
.table-bordered thead td {
  border-bottom-width: 2px;
}

.table-striped tbody tr:nth-of-type(odd) {
  background-color: rgba(0, 0, 0, 0.05);
}

.table-hover tbody tr:hover {
  background-color: rgba(0, 0, 0, 0.075);
}

.table-primary,
.table-primary > th,
.table-primary > td {
  background-color: #b8daff;
}

.table-hover .table-primary:hover {
  background-color: #9fcdff;
}

.table-hover .table-primary:hover > td,
.table-hover .table-primary:hover > th {
  background-color: #9fcdff;
}

.table-secondary,
.table-secondary > th,
.table-secondary > td {
  background-color: #d6d8db;
}

.table-hover .table-secondary:hover {
  background-color: #c8cbcf;
}

.table-hover .table-secondary:hover > td,
.table-hover .table-secondary:hover > th {
  background-color: #c8cbcf;
}

.table-success,
.table-success > th,
.table-success > td {
  background-color: #c3e6cb;
}

.table-hover .table-success:hover {
  background-color: #b1dfbb;
}

.table-hover .table-success:hover > td,
.table-hover .table-success:hover > th {
  background-color: #b1dfbb;
}

.table-info,
.table-info > th,
.table-info > td {
  background-color: #bee5eb;
}

.table-hover .table-info:hover {
  background-color: #abdde5;
}

.table-hover .table-info:hover > td,
.table-hover .table-info:hover > th {
  background-color: #abdde5;
}

.table-warning,
.table-warning > th,
.table-warning > td {
  background-color: #ffeeba;
}

.table-hover .table-warning:hover {
  background-color: #ffe8a1;
}

.table-hover .table-warning:hover > td,
.table-hover .table-warning:hover > th {
  background-color: #ffe8a1;
}

.table-danger,
.table-danger > th,
.table-danger > td {
  background-color: #f5c6cb;
}

.table-hover .table-danger:hover {
  background-color: #f1b0b7;
}

.table-hover .table-danger:hover > td,
.table-hover .table-danger:hover > th {
  background-color: #f1b0b7;
}

.table-light,
.table-light > th,
.table-light > td {
  background-color: #fdfdfe;
}

.table-hover .table-light:hover {
  background-color: #ececf6;
}

.table-hover .table-light:hover > td,
.table-hover .table-light:hover > th {
  background-color: #ececf6;
}

.table-dark,
.table-dark > th,
.table-dark > td {
  background-color: #c6c8ca;
}

.table-hover .table-dark:hover {
  background-color: #b9bbbe;
}

.table-hover .table-dark:hover > td,
.table-hover .table-dark:hover > th {
  background-color: #b9bbbe;
}

.table-active,
.table-active > th,
.table-active > td {
  background-color: rgba(0, 0, 0, 0.075);
}

.table-hover .table-active:hover {
  background-color: rgba(0, 0, 0, 0.075);
}

.table-hover .table-active:hover > td,
.table-hover .table-active:hover > th {
  background-color: rgba(0, 0, 0, 0.075);
}

.table .thead-dark th {
  color: #fff;
  background-color: #212529;
  border-color: #32383e;
}

.table .thead-light th {
  color: #495057;
  background-color: #e9ecef;
  border-color: #dee2e6;
}

.table-dark {
  color: #fff;
  background-color: #212529;
}

.table-dark th,
.table-dark td,
.table-dark thead th {
  border-color: #32383e;
}

.table-dark.table-bordered {
  border: 0;
}

.table-dark.table-striped tbody tr:nth-of-type(odd) {
  background-color: rgba(255, 255, 255, 0.05);
}

.table-dark.table-hover tbody tr:hover {
  background-color: rgba(255, 255, 255, 0.075);
}

 .table {
    border-collapse: collapse !important;
  }
  .table td,
  .table th {
    background-color: #fff !important;
  }
  .table-bordered th,
  .table-bordered td {
    border: 1px solid #ddd !important;
  }
.table>thead>tr>th {
    color: #020202;
    font-weight: 600;
    background: #fff;
    color: #666;
    border-bottom: 1px solid #c0cfde !important;
    padding: 6px 2px 4px 8px;
    overflow: hidden;
    white-space: normal;
    border-left: 1px solid #f6f6f6 !important;
    border-right: 1px solid #f6f6f6 !important;
    height: 20px !important;
    text-transform: uppercase;
}
 
 
.spinner {
  width: 100%;
  text-align: center;
}

.spinner > div {
  width: 9px;
  height: 9px;
  background-color: #4dbdff;

  border-radius: 100%;
  display: inline-block;
  -webkit-animation: sk-bouncedelay 1.4s infinite ease-in-out both;
  animation: sk-bouncedelay 1.4s infinite ease-in-out both;
}

.spinner .bounce1 {
  -webkit-animation-delay: -0.32s;
  animation-delay: -0.32s;
}

.spinner .bounce2 {
  -webkit-animation-delay: -0.16s;
  animation-delay: -0.16s;
}

@-webkit-keyframes sk-bouncedelay {
  0%, 80%, 100% { -webkit-transform: scale(0) }
  40% { -webkit-transform: scale(1.0) }
}

@keyframes sk-bouncedelay {
  0%, 80%, 100% { 
    -webkit-transform: scale(0);
    transform: scale(0);
  } 40% { 
    -webkit-transform: scale(1.0);
    transform: scale(1.0);
  }
}






/* The switch - the box around the slider */
.switch {
  position: relative;
  display: inline-block;
  width: 30px;
  height: 17px;
}

/* Hide default HTML checkbox */
.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

/* The slider */
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: .4s;
  transition: .4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 13px;
  width: 13px;
  left: 2px;
  bottom: 2px;
  background-color: white;
  -webkit-transition: .4s;
  transition: .4s;
}

input:checked + .slider {
     background-color: #5cc3ff;
}

input:focus + .slider {
  box-shadow: 0 0 1px #2196F3;
}

input:checked + .slider:before {
  -webkit-transform: translateX(13px);
  -ms-transform: translateX(13px);
  transform: translateX(13px);
}

/* Rounded sliders */
.slider.round {
  border-radius: 17px;
}

.slider.round:before {
  border-radius: 50%;
}

 

.bg-success td{
    background-color: #efffe8 !important;
    color: #000;
}

.dateselector{
    border: 2px solid #5cc3ff !important;
    background: #e2f5ff !important;
    border-radius:3px !important;
}
.no-border{
border:0px solid transparent !important;
}
button[disabled]{
    opacity: 0.5;
    color: white;
}

.table-light-border{
      border: 1px solid #ecebeb;
    border-top: 0px; }
 
.table>thead>tr>th, .table>tbody>tr>th, .table>tfoot>tr>th, .table>thead>tr>td, .table>tbody>tr>td, .table>tfoot>tr>td {
 
    vertical-align: middle !important;
}
.table>thead>tr>th, .table>tbody>tr>th, .table>tfoot>tr>th{
	text-align:center !important;
}

.input-transparent{
    background: initial !important;
}
.disabled{
    pointer-events:none;
    opacity:0.5;
}
.text-blue{
    color: #5cc3ff !important;
}

.no-span span{
 display:none
}

.btn-outline-blue,.btn-outline-blue[disabled]{
    background: #5cc3ff;
    color: #5cc3ff;
    border: 1px solid #5cc3ff;
    background: white;
    background: transparent;
}

.block-border-blue{
border:2px solid #5cc3ff;
}

.grey-block
{
background:#f7f7f7 !important;
}
.grey-block .divider{
background:#f7f7f7 !important;
}
.grey-block .dividerText{
background:#f7f7f7 !important;
}

.has-currency .currency {
float:left;
opacity: 0.3;
}

.has-currency .value {
float:right;
}

.help{
    top: 0px !important;
    left: 5px !important;
    margin: 0 !important;
    display: inline-block !important;
}
.bg-selected td{
background: #dcf4fc !important;
    border-color: #d2e7ef !important;
}

.netting-container, .section-totals{
  -webkit-transition: width 0.5s, height 0.5s; /* For Safari 3.1 to 6.0 */
  transition: width 0.5s, height 0.5s;
}

td .status{
 width:20px;
}

td .status-netted{
 background:green;
}

tr td.invoice-status-ready{
    color: #49a92c;
    background: #dcfcdf !important;
    border-left: 3px solid #49a92c !important;
}
tr td.invoice-status-ineligible {
    color: #a9a12c;
    background: #fbfcdc !important;
    border-left: 3px solid #a9a12c !important;
}

__________________________________________________________
/**to do : 
optimize renders
wiget presents next structure:
    <NettingContainer>
        <NavToolBar>
        <Netting>
            ...
            <NettingDetailsTable_>
            <NettingDetailsTable_>
        </Netting>
    </NettingContainer>
*/

const calculateWidthWidget = () => {  
    //got from function resizeContent() //core.js
    const sw = $("#sidebar-wrapper");
    const sbWidth =  sw? $(sw).width() : 0;
    const treeWidth = treeExpandState == 'EXPANDED' ? $('#treeMenu').width() : 0;
    const gridWidth = $(window).width() - treeWidth - $('#collapseTree').width() - 60 - sbWidth;
    return gridWidth;
}
    
    BPSystem.initialize();
    const BSIT = 'Buy Side Invoice Total';
    const SSIT ='Sell Side Invoice Total';
    const OA_ = 'Offset Amount';
    const NA_ = 'Netted Amount';
    const SAVE_STATE_VARIABLE = 'widget_state_data'; //save to local storage
    const SAVE_USERINPUT_VARIABLE = "user_state_data"
    const FIELD_APPROVE_INVOICE = "InvoiceStatus";
    const FIELD_KEY = "InvoiceID"; // field for calculation and filter of calc results
    const ALLOWED_INVOICES = ["READY"]; //for this statuses of invoices we can do Netting
    const DATE_FORMATTER = {DB:'YYYY-MM-DD' , UI:'MM/DD/YYYY'};
    const CURRENCY_SYMBOL = "$";
    const TABLE_PAGE_COUNT = 100;
    const INVOICE_TYPE_BUY = 0;
    const INVOICE_TYPE_SELL = 1;
    const PAYMENT_TYPE_BUY = 'Buyer Offset';
    const PAYMENT_TYPE_SELL = 'Seller Offset';
    const ACCOUNT_TYPE_BUYER = 'BUYER';
    const ACCOUNT_TYPE_SELLER= 'SELLER';
    const PAYMENT_NOTE = '##### Netting test'
    const PAGING_TABLES = false;
    const WIDGET_VERSION_VARIABLE = 'version_';
    const VERSION = 1.2;
    //user input variables
    let NETTING = new BPUI.ReferenceObject(BPSystem.toBPObject({}, BPConnection.Netting));
    let CURRENT_DATE =  new BPUI.ReferenceObject(moment(new Date()).format(DATE_FORMATTER.UI) );
    let NETTING_GROUPS =  new BPUI.ReferenceObject();

    let WIDGET_WIDTH = calculateWidthWidget()+'px';
    let UPDATE_RESIZE_TIMEOUT = 500;//ms delay for window.resize re-calc width of component
    let UPDATE_RESIZE_QUEED = null; 

    
    const queryMain = (dueDate = moment(new Date()).format(DATE_FORMATTER.DB),account={
                        accountType:'',
                        accountID:-1,
                           nettingGroup:''},
                        offsetRows=0, 
                        countRows=TABLE_PAGE_COUNT) =>
        ("SELECT  "+
        "i1.DueDate as NetDate, "+
        "a1.id AS AccountId, "+
        "a1.AccountNumber AS Account, "+
        "a1.Name AS AccountName, "+
        "i1.billingprofileid as bProfileID, "+
        "i1.id AS InvoiceID, "+
        "i1.GrandTotalAmount AS InvoiceCharges, "+
        "i1.PaymentAmount AS Payments,  "+
        "i1.CreditAmount AS Adjustments, "+
        "(i1.GrandTotalAmount-i1.CreditAmount-i1.PaymentAmount) AS OutstandingAmount, "+
         "(SELECT n1.netting_statement FROM netting n1 WHERE i1.netted_id = n1.id and rownum=1 ) AS Statement, "+
        "a1.nettinggroup, "+
        "(bp1.PaymentTermDays || ' days') AS  PaymentTermDays, "+
        "CASE "+
        "WHEN i1.netted_id IS NOT NULL THEN 'NETTED'  "+
        "WHEN i1.netted_id IS NULL AND i1.ApprovalStatus = 'APPROVED' AND i1.DueDate<='"+moment(dueDate).format(DATE_FORMATTER.DB)+"' THEN 'READY' "+ 
        "ELSE 'INELIGIBLE'  "+
        " END as InvoiceStatus "+
        "FROM invoice i1 "+
        "JOIN billing_profile bp1 ON i1.billingprofileid = bp1.id "+
        "JOIN account a1 ON bp1.accountid = a1.id "+
        "WHERE 1=1 "+
          (account.nettingGroup =='Unassigned'?" AND a1.AccountNumber  = "+account.accountID+" ":" AND a1.nettinggroup = '"+account.nettingGroup+"' ")+
        "AND a1.AccountType = '"+account.accountType+"' "+
        "ORDER BY  14 DESC,i1.id ASC "+
        (PAGING_TABLES? " OFFSET "+(+offsetRows*+countRows)+" ROWS FETCH NEXT "+countRows+" ROWS ONLY":""));
    
    const queryMainRowCount = (dueDate = moment(new Date()).format(DATE_FORMATTER.DB),account={
                                accountType:'',
                                accountID:-1,
                                nettingGroup:''}) =>
       ("SELECT COUNT(i1.id) as rowCount "+
        "FROM invoice i1 "+
        "JOIN billing_profile bp1 ON i1.billingprofileid = bp1.id "+
        "JOIN account a1 ON bp1.accountid = a1.id "+
        "WHERE 1=1 "+
        (account.nettingGroup =='Unassigned'?" AND a1.AccountNumber  = "+account.accountID+" ":"AND a1.nettinggroup = '"+account.nettingGroup+"' ")+
        "AND a1.AccountType = '"+account.accountType+"' "
       );
    
    const queryNettGroups = (accountID = -1) =>( 
    "SELECT DISTINCT NVL(a1.nettinggroup,'Unassigned') as NettingGroup, a.id as GroupID "+
    "FROM account a "+
    "JOIN account a1 ON a.id = a1.parentaccountid "+
    "WHERE 1=1 "+
    "AND a1.accounttypeid = 722 "+  
    "AND a.id = "+accountID+" " 
    );
    
    const queryTypes = {
        GET_INVOICES_BUY: String('GET_INVOICES_BUY'),
        GET_INVOICES_SELL: String('GET_INVOICES_SELL'),
        GET_PAGESCOUNT_BUY: String('GET_PAGESCOUNT_BUY'),
        GET_PAGESCOUNT_SELL: String('GET_PAGESCOUNT_SELL'),
        GET_NETTING_GROUPS: String('GET_NETTING_GROUPS'),
    };
    
    const columns__ = [    		
    {field:'InvoiceStatus', label:'Status', width:'100'},  
    {field:'InvoiceID', label:'Invoice ID'},
    {field:'NetDate', label:'Net Date', width:'100'},
    {field:'AccountId', label:'Account Id', width:'100'},	
    {field:'Account', label:'Account Number', width:'100'},	
    {field:'AccountName', label:'Account Name', width:'250'},	
    {field:'InvoiceCharges', label:'Invoice Charges', width:'100'},	
    {field:'Payments', label:'Payments', width:'100'},	
    {field:'Adjustments', label:'Adjustments', width:'100'},
    {field:'Offset', label:'Offset', width:'100'},
    {field:'OutstandingAmountTotal', label:'Outstanding Amount', width:'100'},	
    {field:'PaymentTermDays',label:'Pay terms', width:'100'},
    {field:'Statement', label:'Statement', width:'100'}
    ];
    
    Array.prototype.insert = function (index,item){
        this.splice( index, 0, item );
    };
    String.prototype.formatNumber = function(n = 2,x = 3){
        if (Number.isNaN(+this)) { return (this || "").toString()}
        const this_ = +this; 
        const re = '\\d(?=(\\d{' + (x) + '})+' + (n > 0 ? '\\.' : "$") + ')';
        return this_.toFixed(Math.max(0, ~~n)).replace(new RegExp(re,'g'),"$"+'&,');
    }
    String.prototype.formatDate = function(){
           return moment(this).format(DATE_FORMATTER.UI)
    };
    String.prototype.replaceIfNegativeNumber = function(){
        return /^-/.test(this)? '('+(this.replace('-',''))+')':this.toString()
    };
    Number.prototype.replaceIfNegativeNumber = function(){
        return /^-[0-9]\d*(\.\d+)?$/.test(+this)? '('+(this*-1)+')':this.toString()
    };
 
    const settings = {
        labels:{
            tableTypeBuy:('Buy Side'),
            tableTypeSell:('Sell Side'),
            haventOffset:('-'),
            netSelectColumnName:('NET'),
            OffsetColumnName:('Offset'),
            noDataPrimary:('Select Account and Netting Group Code'),
            noDataSecondary:('to see buy and sell side invoices'),
            noDataTable:('Haven\'t data for available invoices'),
            netDate:('Net As of Date'),
            company:('Company'),
            groupCode:('Netting Group Code'),
            nettingTotals:('Netting Totals'),
            submitBtn:('Save netting'),
            resetBtn:('Reset'),
            resetDlg:('Are you sure want to reset all offsets to default calculation?'),
            helpText:('1.Select lines of Buy and Sell tables for netting calculation 2. Click [Save netting] button in Netting Totals section for save Netting results'),
            toSeller:('to the Seller'),
            toBuyer:('to the Buyer'),
            userInput:('Input parameters'),
            switchtoOne:('Switch to 1-column view'),
            switchtoTwo:('Switch to 2-column view'),
            step1Title:('Step 1'),
            step1Descr:('Select Date, Company and Netting Group Code. Then you will see netting data.'),
            step2Title:('Netting Totals'),
            step2Descr:('Click [Save netting] button for save Netting results.'),
            tablesSelect:('Choose/Unchoose the lines of this table for netting. For that click on checkbox for each line you want add for calculation. Totals of netting will be re-calculated automatically.'),
            groupIsNotSelected:('- Not selected - '),
            dlgTitle:('Netting data was send'),
            loadedPreviousText:('Widget was loaded from session of last usage. Since that time data could be changed. Click for hide. '),
            resetUserToDefault:('Reset')
        }
    };
    
    const NavToolBar = React.createClass({
      shouldComponentUpdate(){ return false},
      render() {
        return (<div className="container-fluid">
                    <BPUI.NavToolBar>
                         <div align="left" className="returnToList pr-4">
                              <a 
                              href="javascript:add_attr_submit('SET_FORM_VIEW', 'form_type_in', 'FL')"	
                              className="return-btn"/>
                          </div>
                    </BPUI.NavToolBar>
                </div>)
            }
    });
    
    
    const NettingDetailsTable_ = React.createClass({
        render() { 
            console.log('%c [render] ' + this.constructor.displayName,'color:red',this.props);
        const {type,data,offsets,maxPagesCount,keyFieldName,columns,onSetStep,currentPage,
            selectedRowIndex,formatDateColumnIndex : FDC, formatNegativeNColumnIndex : FNI,
            currencyColumnIndex, currencySymbol
            } = this.props;
        const {labels} = settings;
        const labelType = [[labels.tableTypeBuy],[labels.tableTypeSell]];
        const columnsToHTML = columns.map((column,index)=><th className="py-4_" scope="col" key={index}><div style={{width:column.width? column.width+'px':'100px'}}>{column.label}</div></th>);
        const dataTmp = data.length>0? [...data].map(el=> {
            //calculation of offset field
            const index_ = offsets.findIndex(offsetEl=>+offsetEl.invoiceId===+el[keyFieldName]);
            const offsetValue =  index_>-1? offsets[index_].offset:0;
            const totalAmountValue = index_>-1? offsets[index_].OutstandingAmountTotal:el.OutstandingAmount ;
                return ({...el, 
                    Offset:offsetValue,
                    OutstandingAmountTotal:totalAmountValue
                })})
            :[];
    
        const dataToHTML_ =  dataTmp.map((el,index)=> (
            <tr className={`${ ALLOWED_INVOICES.includes(el[FIELD_APPROVE_INVOICE])? selectedRowIndex.includes(+el[keyFieldName])?'bg-selected':'':'disabled'} table-row`}>
                              <td onClick={()=>this.props.onSelectRow(+el[keyFieldName])}>
                                  <span className="status status-netted"></span>
                                  <input type="checkbox" readOnly checked={selectedRowIndex.includes(+el[keyFieldName])} /></td>
                              {
                               columns.map((column,index)=>
                               <td className={`${column.field==='InvoiceStatus'? 
                               el[column.field]==='READY'?'invoice-status-ready':
                                  el[column.field]==='NETTED'?'invoice-status-netted': 
                                   el[column.field]==='INELIGIBLE'?'invoice-status-ineligible':''                               
                               :''}`}>
                                     <div className={`${currencyColumnIndex.includes(index)? 'has-currency':'' } field`}>
                                         {
                                          currencyColumnIndex.includes(index)? <span className="currency">{currencySymbol}</span>:null   
                                         }
                                         <span className="value">
                                        {  FDC.includes(index)? String(el[column.field]).formatDate()
                                        : FNI.includes(index)? String(el[column.field]).formatNumber().replaceIfNegativeNumber()
                                            :el[column.field]
                                        }
                                        </span>
                                    </div>
                                 </td>)
                              }
                       </tr>)
         );   
        return(
            <div className="detail-table">
            <div className="row p-0 m-0">
                <div className="divider pb-0">
                    <div className="dividerText py-2">{labelType[type] || null}
                    <BPUI.HelpText name={'tooltip'} shortHelp={labelType[type]+' table'} longHelp={[labels.tablesSelect]}/>
                    </div>   
                </div> 
            </div>                                                                           
            <div className="table-light-border">
             <div className="table-responsive">
                <table className="table" >
                    <thead>
                    <tr>
                        <th>{[labels.netSelectColumnName]}</th>
                        {columnsToHTML}
                    </tr>
                    </thead>
                    <tbody>
                    {dataToHTML_}  
                    </tbody>
                </table>
            </div> 
            <div className="row p-2 m-0 table-footer">
            {
                data.length===0? 
                <div className="col-sm-12 text-center py-3 alert-warning">
                        <div>{[labels.noDataTable]}</div>
                </div>
                :null
            }    
            {
            PAGING_TABLES ?
                <div className="table-paging">      
                    <div className="col-sm-6 text-right mt-2">Page {currentPage+1} of {maxPagesCount+1 || '1'}</div>
                    <div className="col-sm-6 text-right">
                        <span onClick={()=>onSetStep(currentPage-1<0?0:currentPage-1)} className={`px-3 btn ${+currentPage===0?'disabled':''}`}><i className="fa fa-chevron-left" /></span>
                        <span onClick={()=>onSetStep(currentPage+1>maxPagesCount?maxPagesCount:currentPage+1)} className={` btn  ${+currentPage===+maxPagesCount?'disabled':''}`}><i className="fa fa-chevron-right"></i> </span>
                    </div>
               </div> 
            :null
            }
            </div>
             </div>
            </div> 
           )
        }            
    }); 
                       
    const Netting = React.createClass({
        getInitialState(){
            return({
                twoColView:true
            })
        },
        render(){
         console.log('%c [render] ' + this.constructor.displayName,'color:red',this.props);
            const {twoColView} = this.state;
            const {labels} = settings;
            const preLoader = (<div className="col-sm-12">
                <div className="spinner py-5">
                  <div className="bounce1"></div>
                  <div className="bounce2"></div>
                    <div className="bounce2"></div>
                </div></div>);
            const haveNoData = (<div className="col-sm-12 text-center py-5 my-5 alert-warning">
                   <div>{[labels.noDataPrimary]}</div>
                   <small>{[labels.noDataSecondary]}</small>            
                </div>);
               
            let {padgingTables,step,isWaiting,noData,data,currencySymbol} = this.props;
            padgingTables = padgingTables || {padgingTables:{maxBuy:0,currentBuy:0,maxSell:0,currentSell:0}};
            const {nettingGroups,detailedData,offsets,totals,selectedRowIndexBuy,selectedGroup,selectedRowIndexSell} = data || {selectedRowIndexBuy:[],selectedRowIndexSell:[],detailedData:{buy:[],sell:[]},offsets:{buy:[],sell:[]}};
            const noDataBuyOrSell = (detailedData.buy.length===0 || detailedData.sell.length===0);
            const noDataSelected = (offsets.buy.length===0 || offsets.sell.length===0)
            const totalsToHTML = Object.values(totals || []).map(el=>
                <div className="row p-0 m-0 pt-4">
                    <div className="col-sm-6 text-right">{el.title}</div>
                    <div className="col-sm-6 has-currency"><span className="currency">{currencySymbol}</span><span className="value">{String(el.value).formatNumber().replaceIfNegativeNumber()}</span></div>
                </div>);
            const nettingGroupsToHTML = (nettingGroups || []).map((el,i)=><option key={i} value={el.GroupID}>{el.NettingGroup}</option>);
            return(<div className="pt-3">
                 <div className="row">
                <section className="section-user-input px-2 col-sm-6"> 
                <div className="row p-0 m-0">
                   <div className="divider"><div className="dividerText py-2">{[labels.userInput]}<BPUI.HelpText name={'tooltip'} shortHelp={[labels.step1Title]} longHelp={[labels.step1Descr]}/></div> </div> 
                </div> 
                    <div className="row  p-0 m-0">
                        <div className="col-sm-6 pt-2"><img alt="" src="images/required.png"/>{[labels.netDate]}</div>
                        <div className="col-sm-6">
                            <BPUI.InputField key="1112" format="mm/dd/yy" className="dateselector" variable={CURRENT_DATE} placeholder="Click for select..." layout="plain" type="DATE_SELECTOR" onUpdate={(date,val2,val3)=>{this.props.onDateChange(date)}}/>                                    
                        </div>
                    </div>
                    <div className={`row p-0 m-0 pt-4 ${step<1?'disabled':''}`}>
                        <div className="col-sm-6 pt-2">
                            <img alt="" src="images/required.png"/> 
                            <span>{[labels.company]}</span>
                        </div>
                        <div className="col-sm-6 lookup23__">
                            <BPUI.InputField variable={NETTING} className="input nnn"  placeholder="Click for select..."field="account_id" onUpdate={(id,type,object)=>{this.props.onChangeAccount(id)}} layout="plain" />
                        </div>
                    </div>
                    <div className={`row p-0 m-0 pt-4 ${ (step<2) ?'disabled':''}`}>
                        <div className="col-sm-6 pt-2">
                            <img alt="" src="images/required.png"/>
                            <span>{[labels.groupCode]}</span>     
                        </div>
                        <div className="col-sm-6 no-span">
                            <select className="w-100" value={selectedGroup} onChange={(e)=>{this.props.onChangeGroup(e.target.value)}}>
                                <option value='-1'>{[labels.groupIsNotSelected]}</option>
                                {nettingGroupsToHTML}
                            </select>
                        </div>
                    </div>
                </section>
                <section className={`section-totals col-sm-6 px-2 ${(noData || isWaiting || noDataBuyOrSell || noDataSelected)?'disabled':'' }`}>
                    <div className="grey-block  pb-3">
                        <div className="row p-0 m-0">
                        <div className="divider"><div className="dividerText py-2">{[labels.nettingTotals]}<BPUI.HelpText name={'tooltip'} shortHelp={[labels.step2Title]} longHelp={[labels.step2Descr]}/></div> </div> 
                        </div>
                        {totalsToHTML}
                        {
                            +totals.offsetAmount.value===0?'':
                                <div className="row p-0 m-0 pt-4 text-center">
                                    <div className="col-sm-6"/>
                                    <div className="col-sm-6 text-right"><h3>{ +totals.offsetAmount.value>0?[labels.toSeller]:[labels.toBuyer] }</h3></div>
                                </div>
                        }
                        <div className="row p-0 m-0 pt-2">
                        <div className="col-sm-12 text-right"> 
                            <button className="btn btn-outline-blue " disabled={selectedRowIndexBuy.length===0 && selectedRowIndexSell.length===0 }  onClick={()=>this.props.onSelectionReset()}><i className="fa fa-undo"/> {[labels.resetBtn]}</button>                
                            <button onClick={()=>this.props.onSaveData()} className="btn ml-1"><i className="fa fa-cloud-upload" /> {[labels.submitBtn]}</button>
                        </div>                    
                        </div>
                    </div>
                </section>
                {noData? haveNoData:  isWaiting? preLoader:
                <section className="section-detail-tables col-sm-12"> 
                 <div className="row">
                  <div className="col-sm-12 mt-3"><label className="switch"><input checked={twoColView} onChange={()=>this.setState({twoColView:!twoColView})} type="checkbox"/><span className="slider round"></span></label> </div>    
                      <div className="col-sm-12" style={{opacity:0.6}}>{twoColView?[labels.switchtoOne]: [labels.switchtoTwo]}</div>
                    <div className={`${twoColView? 'col-sm-6':'col-sm-12'} text-center px-2`}>
                    <NettingDetailsTable_ 
                       type={INVOICE_TYPE_BUY}
                       maxPagesCount={padgingTables.maxBuy}
                       currentPage={padgingTables.currentBuy}
                       keyFieldName={FIELD_KEY}
                       data={detailedData.buy}
                       offsets={offsets.buy} 
                       formatDateColumnIndex={[2]}
                       currencySymbol={currencySymbol} 
                       currencyColumnIndex={[6,7,8,9,10]} 
                       formatNegativeNColumnIndex={[6,7,8,9,10]}
                       columns={columns__}
                       onSelectRow={(rowIndex)=>this.props.onSelectRowBuy(rowIndex)}
                       selectedRowIndex={selectedRowIndexBuy}
                       onSetStep = {page=>this.props.onSetPageBuy(page)}
                    />
                   </div>
                   <div className={`${twoColView? 'col-sm-6':'col-sm-12'} text-center px-2`}>
                    <NettingDetailsTable_ 
                       type={INVOICE_TYPE_SELL}
                       maxPagesCount={padgingTables.maxSell}
                       currentPage={padgingTables.currentSell}
                       keyFieldName={FIELD_KEY}
                       data={detailedData.sell}
                       offsets={offsets.sell}
                       formatDateColumnIndex={[2]}
                       currencySymbol={currencySymbol} 
                       currencyColumnIndex={[6,7,8,9,10]}
                       formatNegativeNColumnIndex={[6,7,8,9,10]}
                       columns={columns__}
                       onSelectRow={(rowIndex)=>this.props.onSelectRowSell(rowIndex)}      
                       selectedRowIndex={selectedRowIndexSell}
                       onSetStep = {page=>this.props.onSetPageSell(page)}      
                    />
                   </div>                          
                 </div>
                </section>  
            }            
           </div>
        </div>)
        }
    });
    //data cotainer                                         
    const NettingContainer = React.createClass({  
        getInitialState() {
        return {
             netDate:CURRENT_DATE.getValue(),
             nettingAccount:-1,             
             nettingGroup:-1,
             nettingGroups:[],
             isWaiting:true,
             loadedPrevious:null,
             noData:true,
             padgingTables:{
                 currentBuy:0,
                 currentSell:0,
                 maxBuy:0,
                 maxSell:0
             },
             detailedData:{buy:[],sell:[]},
             selectedRowIndexBuy:[],selectedRowIndexSell:[],
             offsets:{
                 buy:[],
                 sell:[],
             },
             totals:{
                 buyInvoiceTotal:{title:BSIT, value:0},
                 sellInvoiceTotal:{title:SSIT, value:0},
                 netAmount:{title:OA_, value:0},
                 offsetAmount:{title:NA_, value:0},
                }
            }
        },
        prevStep(){
            let newStep = this.state.step-1;
            this.setState({
                step:newStep<0?0:newStep
            });
        },
        async onDateChange(date){
          await  this.setState({netDate:date});
          this.checkParams__then(this.getDataInvoices)
        },
        async onAccChange(id){
           //dont call data load here, cause groupID depends on accountID
           await this.setState({nettingAccount:id,nettingGroup:-1,noData:true});
          this.getData(queryTypes.GET_NETTING_GROUPS,{id})
        },
        async onGroupChange(id){
          await this.setState({nettingGroup:id});
          this.checkParams__then(this.getDataInvoices)
        },
        checkParams__then(callback){
            //check state parameters for know when to load all data with params
            const {netDate,nettingAccount,nettingGroup} = this.state;
            if (netDate===-1 || nettingAccount===-1 || nettingGroup===-1) {
            }else{
            callback()
            }
        }, 
        async setPage(page=0,type=INVOICE_TYPE_BUY/*0 - buy, 1 - sell*/){
          const {padgingTables} = this.state;
          const res = await this.getData(type===INVOICE_TYPE_BUY?queryTypes.GET_INVOICES_BUY:queryTypes.GET_INVOICES_SELL,{},page);
            if (res){ // if data have been received -> change page
              this.setState({
              padgingTables: type===INVOICE_TYPE_BUY?
              {...padgingTables,currentBuy:page}:
              {...padgingTables,currentSell:page}
             });
            }
        },
            
        async getData(type='',params={},offsetRows=0, countRows=TABLE_PAGE_COUNT){
            const {netDate, nettingAccount, nettingGroup, nettingGroups} = this.state;
            const groupObject = nettingGroups.find(el=>el.GroupID===nettingGroup);
            const groupName  = groupObject? groupObject.NettingGroup:'';
            const accountBuy ={
                accountType:ACCOUNT_TYPE_BUYER,
                accountID:nettingAccount,
                nettingGroup:groupName
            },accountSell = {
                accountType:ACCOUNT_TYPE_SELLER,
                accountID:nettingAccount,
                nettingGroup:groupName
            }
            try {
            switch(type){
              case queryTypes.GET_INVOICES_BUY:{
                      await this.setState({detailedData:{...this.state.detailedData,buy:[]}});
                      const [res] = await Promise.all([BPConnection.BrmAggregate.queryAsync(queryMain(netDate,accountBuy,offsetRows)).collection()]);
                      const resList =  res.elements;
                      await this.setState({detailedData:{...this.state.detailedData,buy:resList}});
                      break;
                    }
              case queryTypes.GET_INVOICES_SELL:{
                    await this.setState({detailedData:{...this.state.detailedData,sell:[]}});
                      const [res] = await Promise.all([BPConnection.BrmAggregate.queryAsync(queryMain(netDate,accountSell,offsetRows)).collection()]);
                      const resList =  res.elements;
                      await this.setState({detailedData:{...this.state.detailedData,sell:resList}});
                      break;
                    }
              case queryTypes.GET_PAGESCOUNT_BUY:{ 
                 await this.setState({padgingTables:{...this.state.padgingTables,maxBuy:0}});
                   const [res] = await Promise.all([BPConnection.BrmAggregate.queryAsync(queryMainRowCount(netDate,accountBuy)).single()]);
                  await this.setState({padgingTables:{...this.state.padgingTables,maxBuy: Math.ceil(+res.rowCount/TABLE_PAGE_COUNT)-1}});
                  break;}
              case queryTypes.GET_PAGESCOUNT_SELL:{
                await this.setState({padgingTables:{...this.state.padgingTables,maxSell:0}});
             const [res] = await Promise.all([BPConnection.BrmAggregate.queryAsync(queryMainRowCount(netDate,accountSell)).single()]);
                  await this.setState({padgingTables:{...this.state.padgingTables,maxSell: Math.ceil(+res.rowCount/TABLE_PAGE_COUNT)-1}});
                  break;}
              case queryTypes.GET_NETTING_GROUPS:{ 
                await this.setState({nettingGroups:[]});
                  const [res] = await Promise.all([BPConnection.BrmAggregate.queryAsync(queryNettGroups(params.id)).collection()]);
                  const resList = res.elements;
                  await this.setState({nettingGroups:resList});
                  break;}
              default : return false;
            }}
            catch (e){ return false}
            return true;
        }, 
        async getDataInvoices(){
          //aggregate results of data Buy and Sell with pagesCounts for detailed tables
          await this.setState({isWaiting:true, noData:false});
          const [buyInv,sellInv, buyCount, sellCount] = await Promise.all([
                    this.getData(queryTypes.GET_INVOICES_BUY),
                    this.getData(queryTypes.GET_INVOICES_SELL),
                    this.getData(queryTypes.GET_PAGESCOUNT_BUY),
                    this.getData(queryTypes.GET_PAGESCOUNT_SELL)
          ]);      
          await this.setState({
              isWaiting:false, 
              noData:!((buyInv||sellInv)&&buyCount&&sellCount)
            });
          this.selectAllData();
        },
        resizeEvent(){
                console.warn('...widget resized...');
                 if (UPDATE_RESIZE_QUEED) clearTimeout(UPDATE_RESIZE_QUEED);
                        UPDATE_RESIZE_QUEED = setTimeout(() =>  this.forceUpdate(), UPDATE_RESIZE_TIMEOUT);
        },    
        async componentDidMount(){
            $(window).on("resize", this.resizeEvent);
            const ver = window.localStorage[WIDGET_VERSION_VARIABLE];
            if (ver==VERSION) {
            const savedStateData = window.localStorage[SAVE_STATE_VARIABLE];
            const savedUserInput = window.localStorage[SAVE_USERINPUT_VARIABLE];
            if (savedStateData && savedUserInput) {
                   await this.setState(JSON.parse(savedStateData));
                   await this.setState({loadedPrevious:true}); 
            const [n, ng, cd] = JSON.parse(savedUserInput);
            try {
                NETTING.set(BPSystem.toBPObject(n, BPConnection.Netting)); 
                NETTING_GROUPS.set(ng); 
                CURRENT_DATE.set(cd.holder.value);       
                this.getDataInvoices();
                }
                catch(e){ console.error('[error]',e)}
            }}
          console.log('[didmounted] NettingContainer');
        },
        componentWillUnmount() {
            $(window).off("resize",this.resizeEvent);
            $(window).unbind("resize",this.resizeEvent);
        },
        componentDidUpdate(props,state){
          window.localStorage.setItem(SAVE_STATE_VARIABLE,JSON.stringify(state));
          window.localStorage.setItem(SAVE_USERINPUT_VARIABLE,JSON.stringify([NETTING.get(), NETTING_GROUPS, CURRENT_DATE]))
          window.localStorage.setItem(WIDGET_VERSION_VARIABLE, VERSION);
        },
        async selectRowSell(row){            
            const {selectedRowIndexSell} =this.state;   
            const listRows = selectedRowIndexSell.includes(row)?selectedRowIndexSell.filter(i=>i!== row):[row,...selectedRowIndexSell];
            await this.setState({selectedRowIndexSell:listRows});
            this.calcOutputData();	  
        },
        async selectRowBuy(row){
            const {selectedRowIndexBuy} =  this.state    
            const listRows = selectedRowIndexBuy.includes(row)?selectedRowIndexBuy.filter(i=>i!== row):[row,...selectedRowIndexBuy];
            await this.setState({selectedRowIndexBuy:listRows});
            this.calcOutputData();		
        },
        async selectAllData(){
        //select all data for calculations by default
            const {detailedData} = this.state;
              const dataBuy = detailedData.buy
                .filter(el=>ALLOWED_INVOICES.includes(el[FIELD_APPROVE_INVOICE]))
                .map(el=>(+el.InvoiceID));
            const dataSell = detailedData.sell
                .filter(el=>ALLOWED_INVOICES.includes(el[FIELD_APPROVE_INVOICE]))
                .map(el=>(+el.InvoiceID)); 
            await this.setState({
                selectedRowIndexBuy:dataBuy,
                selectedRowIndexSell:dataSell,
            });
            this.calcOutputData();
        },     
        async selectionReset(){
          if (window.confirm([settings.labels.resetDlg])) {
          await this.setState({
              selectedRowIndexBuy:[],
              selectedRowIndexSell:[]});
          this.calcOutputData();
          }
        }, 
        calcOutputData(){
            let {selectedRowIndexBuy,selectedRowIndexSell,detailedData, totals} = this.state; 
            //calc totals
            const selectedDataBuy = [...detailedData.buy
                .filter((el,index)=>selectedRowIndexBuy.includes(+el.InvoiceID) && ALLOWED_INVOICES.includes(el[FIELD_APPROVE_INVOICE]))
                .sort((prev, next)=>+prev.InvoiceID < +next.InvoiceID)];
            const selectedDataSell = [...detailedData.sell
                .filter((el,index)=>selectedRowIndexSell.includes(+el.InvoiceID) && ALLOWED_INVOICES.includes(el[FIELD_APPROVE_INVOICE]))
                .sort((prev, next)=>+prev.InvoiceID < +next.InvoiceID)];
            const buyInvoiceTotal_ = selectedDataBuy.reduce((acc,el,arr)=>acc+=+el.OutstandingAmount,0);
            const sellInvoiceTotal_ = selectedDataSell.reduce((acc,el,arr)=>acc+=+el.OutstandingAmount,0);
             //sell offset max total  = sell offset
            let sellInvoiceTotal_tmp = Math.abs(+sellInvoiceTotal_);
            //buy offset max total  = MIN(sell offset, buy offset)
            const netAmount_ = Math.min(Math.abs(+sellInvoiceTotal_),Math.abs(+buyInvoiceTotal_))
            let buyInvoiceTotal_tmp = netAmount_;
            let buyOffsets = [];
            let sellOffsets = [];
            //offset calc (can be calculated in parallel)
            //buy section
            selectedDataBuy.map(el=>{
                let offsetBuy = 0;  
                if (Math.abs(+el.OutstandingAmount)>Math.abs(+sellInvoiceTotal_tmp)){
                    offsetBuy =sellInvoiceTotal_tmp ===0?0: Math.abs(+sellInvoiceTotal_tmp)
                }
                else{
                    offsetBuy = Math.abs(+el.OutstandingAmount); 
                }
                      
                buyOffsets.push({
                    invoiceType:INVOICE_TYPE_BUY, 
                    invoiceId:el.InvoiceID,
                    billingId:el.bProfileID,
                    OutstandingAmountTotal:(+el.OutstandingAmount - +offsetBuy),
                    offset:-offsetBuy //add with negative sign (buy side)
                });
            
                sellInvoiceTotal_tmp-=offsetBuy;     
            });
            //sell section
            selectedDataSell.map(el=>{
                let offsetSell = 0;
                if (Math.abs(el.OutstandingAmount)>Math.abs(buyInvoiceTotal_tmp)){
                    offsetSell = Math.abs(+buyInvoiceTotal_tmp)
                }
                else{
                    offsetSell = Math.abs(+el.OutstandingAmount);
                }
                sellOffsets.push({
                    invoiceType:INVOICE_TYPE_SELL, 
                    invoiceId:el.InvoiceID,
                    billingId:el.bProfileID,
                    OutstandingAmountTotal:(+el.OutstandingAmount + +offsetSell),
                    offset:offsetSell //add with positive sign (sell side)
                });
                
                buyInvoiceTotal_tmp-=offsetSell;
            });
            //end offset calc
            console.log('---------selected data [B,S] = ',selectedDataBuy,selectedDataSell);
            console.log('---------offsetts data [B,S] = ',buyOffsets,sellOffsets);
                 
            const offsetInvoiceTotal_ = Math.abs(+sellInvoiceTotal_) - Math.abs(+buyInvoiceTotal_);
            this.setState({
                totals:{
                    ...totals,
                    buyInvoiceTotal:{...this.state.totals.buyInvoiceTotal, value:buyInvoiceTotal_},
                    sellInvoiceTotal:{...this.state.totals.sellInvoiceTotal, value:sellInvoiceTotal_},
                    offsetAmount:{...this.state.totals.offsetAmount, value:offsetInvoiceTotal_},
                    netAmount:{...this.state.totals.netAmount, value:netAmount_},
                },
                offsets:{
                     buy:buyOffsets,
                     sell:sellOffsets
                }
            });          
        },
        async saveCalcData(){
        //+ add check if not empty data
        /** 
         *  1. insert data (totals) into netting_results
         *  2. get ID of total_result
         *  3. insert data (invoices) into payments table (create Payments) with ID of step 2
         *  4. get ID's of Payments
         *  5. insert data (invoices) into payments_allocation with payments ID of them from step 3
         *  6. upsert data in invoice table (ID, netted_id)
         */
        let step_executed = 1;
        const lookupText = document.querySelector('.lookup23__ input[type="text"]');
        const companyLabel  = lookupText? lookupText.value : '';
        const indexGr = this.state.nettingGroups.findIndex(el=>el.GroupID==this.state.nettingGroup);
        let grouplabel =  (indexGr>-1) ? this.state.nettingGroups[indexGr].NettingGroup : "";  
         const nettingResults  = {
            account_id: this.state.nettingAccount,
            company:companyLabel,
            due_date:moment(this.state.netDate).format(DATE_FORMATTER.DB),
            netting_group:grouplabel,
            buy_total:this.state.totals.buyInvoiceTotal.value,
            sell_total:this.state.totals.sellInvoiceTotal.value,
            sell_pay_term:60,
            buy_pay_term:30,
            netted_amount:this.state.totals.netAmount.value,
            netted_as_of_date:moment(this.state.netDate).format(DATE_FORMATTER.DB),
            reversal_date:null,
            netted_status: 'PROCESSED',
            netting_statement: null
         };
            
        let resStatus = null;  
            try{
        // * * * * * *  step 1
        const createNettingResult = await BPConnection.netting.create(nettingResults);
        const invoicesArr = this.state.offsets.buy.concat(this.state.offsets.sell);
        step_executed++;
        // * * * * * *  step 2
        const nettedId_ = createNettingResult[0].Id;
        console.log('[Save data] netted_result -> OK');
        step_executed++;
        // * * * * * *  step 3
        const addPaymentsToInvoices = await BPConnection.Payment.create(
         invoicesArr.map(el=>({
                    Amount:el.offset*-1,
                    BillingProfileId:el.billingId,
                    netted_id:nettedId_,
                    Autoallocate:1, 
                    PaymentType: el.invoiceType === INVOICE_TYPE_BUY? PAYMENT_TYPE_BUY:PAYMENT_TYPE_SELL,
                    PaymentNote: PAYMENT_NOTE,
                    PaymentDate:moment(new Date()).format(DATE_FORMATTER.DB)
            })));
        step_executed++;   
        // * * * * * *  step 4
        const paymentsId = addPaymentsToInvoices.map((el,index)=>({
                PaymentItemId:el.Id,
                InvoiceId:invoicesArr[index].invoiceId,
                Amount:invoicesArr[index].offset
            }));
       step_executed++;

        console.log('[Save data] invoices payments -> ',invoicesArr.length===paymentsId.length);
        if (invoicesArr.length===paymentsId.length) {
      // * * * * * *  step 5
      const addAllocationsToInvoices = await  BPConnection.PaymentAllocation.create(paymentsId);
      console.log('[Save data] invoices allocation -> OK');
      step_executed++
       // * * * * * *  step 6
       const updateInvoiceTable = await BPConnection.INVOICE.upsert(invoicesArr.map(el=>({
            Id:el.invoiceId,
            netted_id:nettedId_ 
       })))
       console.log('[Save data] update invoices -> OK');
       step_executed++;
       console.log(step_executed>6?'executed successfully':'executed with fail',step_executed);

       console.log('%c [undo actions] * * * DO IT FOR UNDO * * *','color:blue');
       console.log('%c [undo actions] const res1 = await BPConnection.INVOICE.update('+JSON.stringify(updateInvoiceTable.map(el=>({Id:el.Id,fieldsToNull:["netted_id"]})))+');','color:blue'); 
       console.log('%c [undo actions] const res2 = await BPConnection.Payment.update('+JSON.stringify(addPaymentsToInvoices.map(el=>({Id:el.Id,Voided:1})))+')','color:blue');
       console.log('%c [undo actions] const res3 = await BPConnection.netting.delete({Id:'+nettedId_+'})','color:blue'); 
       console.log('%c [undo actions] console.log(res1,res2,res3)','color:blue'); 
            resStatus = true;
            } else {
                    resStatus = false;       
            }
            }catch(e){
        console.log('failed on step =',step_executed);
        resStatus = false;    
            }
    
        window.BPActions.showDialog(resStatus?"modalDlg_success":"modalDlg_error", {
          resizable: false, 
          draggable: true, 
          title: [settings.labels.dlgTitle], 
          modal: true, 
          width: 390, 
          maxHeight: (window.innerHeight * 2 / 2), 
          dialogClass: 'dialog-lookup', 
          maxWidth: 450,
          buttons: [{
            text: "OK",
            click:  () => {
                window.BPActions.closeDialog(resStatus?"modalDlg_success":"modalDlg_error");
                if (resStatus){
                    this.getDataInvoices();
                }
            }}]                                            
        });
        },
        render(){
       console.log('%c [render] ' + this.constructor.displayName,'color:red',this.state);
        const {totals,detailedData,loadedPrevious,isWaiting,padgingTables,selectedRowIndexBuy,nettingAccount,selectedRowIndexSell,netDate,offsets,noData,nettingGroups,nettingGroup} = this.state;
        const nettingStep = (netDate === -1)? 0: (nettingAccount===-1)? 1:2;
        WIDGET_WIDTH = calculateWidthWidget()+'px';   
            return(
                 <div className="netting-container" style={{width:WIDGET_WIDTH}}>
                 <NavToolBar />
                 {loadedPrevious? 
                    <div 
                        onClick={()=>this.setState({loadedPrevious:null})} 
                        className="alert-primary p-2">
                            {settings.labels.loadedPreviousText}
                    </div>:null}
                  <Netting
                    step={nettingStep}
                    padgingTables = {padgingTables}
                    onDateChange = {(date)=>this.onDateChange(date)}           
                    onSaveData={()=>this.saveCalcData()}
                    onSelectionReset = {()=>this.selectionReset()} 
                    onSelectRowBuy = {rowIndex=>this.selectRowBuy(rowIndex)}
                    onSelectRowSell = {rowIndex=>this.selectRowSell(rowIndex)}
                    onChangeAccount = {id=>this.onAccChange(id)}
                    onChangeGroup = {id=>this.onGroupChange(id)}
                    onSetPageBuy = {step=>this.setPage(step,INVOICE_TYPE_BUY)}
                    onSetPageSell = {step=>this.setPage(step,INVOICE_TYPE_SELL)}
                    noData={noData}
                    isWaiting={isWaiting}
                    currencySymbol={CURRENCY_SYMBOL}
                    data={{detailedData,
                           totals,
                           offsets,
                           selectedRowIndexBuy,
                           selectedRowIndexSell,
                           nettingGroups,
                           selectedGroup:nettingGroup
                          }}
                   />
                 </div>)
        }
    });
          
